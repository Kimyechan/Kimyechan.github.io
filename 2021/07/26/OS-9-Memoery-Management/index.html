
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Run PSVM">
    <title>OS-9 Memoery Management - Run PSVM</title>
    <meta name="author" content="Yechan Kim">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yechan Kim","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"articleBody":"Logical vs Physical Address\nLogical address (=virtual address)\n프로세스마다 독립적으로 가지는 주소 공간\n각 프로세스마다 0번지부터 시작\nCPU가 보는 주소는 logical address다\n\n\nPhysical address\n메모리에 실제 올라가는 위치\n\n\n주소 바인딩: 주소를 결정하는 것\nSymbolic Address -&gt; Logical Address -&gt; Physical address\n\n\n\n주소 바인딩\nCompile time binding\n물리적 메모리 주소(physical address)가 컴파일 시 알려짐\n시작 위치 변경 시 재컴파일\n컴파일러는 절대 코드(absolute code) 생성\n\n\nLoad time binding\nLoader의 책임하에 물리적 메모리 주소 부여\n프로그램이 메모리에 올라갈 때 물리적 메모리 주소가 정해짐\n컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능\n\n\nExecution time binding(= Run time binding)\n수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음\nCPU가 주소를 참조할 때마다 binding을 점검 (address mapping table)\n실행중에 메모리에 쫓겨나고 다시 메모리에 올라갈 때 (Swapping)\n하드웨어 지원이 필요하다 (e.g., base and limit registers, MMU)\n\n\n\n\n\nMemory-Management Unit (MMU)\nMMU (Memory-Management Unit)\nlogical address를 physical address로 매핑해 주는 Hardware device\n\n\nMMU scheme\n사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (= relocation register)의 값을 더한다\n\n\nuser program\nlogical address만을 다룬다 \n실제 physical address를 볼 수 없으며 알 필요가 없다\n\n\n\n\n\nHardware Support For Address Translation\n운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용하는 레지스터\nRelocation register(= base register) : 접근할 수 있는 물리적 메모리 주소의 최소값\nLimit register: 논리적 주소의 범위\n\n\n\n용어 정리Dynamic Loading\n프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것\nmemory utilization의 향상\n가끔식 사용되는 많은 양의 코드의 경우 유용 (ex. 오류 처리 루틴)\n운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)\nLoading: 메모리로 올리는 것\n\nOverlays\n메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림\n프로세스의 크기가 메모리보다 클 때 유용\n운영체제의 지원없이 사용자에 의해 구현\n작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현\nManual Overlay\n프로그래밍이 매우 복잡\n\n\n\nSwapping\nSwapping : 프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것\nBacking store(=swap area)\n디스크\n많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간\n\n\n\n\nSwap in/ Swap out\n일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정\npriority-based CPU scheduling algorithm\npriority가 낮은 프로세스를 swapped out 시킴\npriority가 높은 프로세스를 메모리에 올려 놓음\n\n\nCompile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야 함\nExecution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음\nswap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임\n\n\n\n\n\nDynamic Linking\nLinking을 실행 시간(execution time)까지 미루는 기법\nStatic linking\n라이브러리가 프로그램의 실행 파일 코드에 포함됨\n실행 파일의 크기가 커짐\n동일한 라이브러리를 각각의 프로스가 메모리에 올리므로 메모리 낭비 (ex. printf 함수의 라이브러리 코드)\n\n\nDynamic linking\n라이브러리가 실행 시 연결(link)됨\n라이브러리 호출부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠\n라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴\n운영체제의 도움이 필요\n\n\n\nAllocation Of Physical Memory\n메모리는 일반적으로 두 영역으로 나뉘어 사용\nOS 상주 영역\ninterrupt vector와 함께 낮은 주소 영역 사용\n\n\n사용자 프로세스 영역\n높은 주소 영역 사용   \n\n\n\n\n사용자 프로세스 영역의 할당 방법\nContiguous allocation : 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것\nFixed partiion allocation\nVariable partition allocation\n\n\nNoncontigous allocation : 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음\nPaging : 논리 메모리를 같은 크기로 자른다\nSegment : 논리 메모리를 의미있는 단위로 자른다 (code, data, stack)\nPaged Segmentation\n\n\n\n\n\nContiguous Allocation\n고정 분할(Fixed partition) 방식\n물리적 메모리를 몇 개의 영구적 분할(partition)로 나눔\n분할의 크기가 모두 동일한 방식과 서로 다른 방식이 존재\n분할당 하나의 프로그램 적재\n융통성이 없음\n동시에 메모리에 load되는 프로그램의 수가 고정됨\n최대 수행 가능 프로그램 크기 제한\n\n\n가변 분할(Variable partition) 방식\n프로그램의 크기를 고려해서 할당\n분할의 크기, 개수가 동적으로 변함\n기술적 관리 기법 필요\nExternal fragmentation 발생\n\n\n\n\n\n\n\n\nFragmentation\nExternal fragmentation(외부 조각)\n프로그램 크기보다 분할의 크기가 작은 경우\n아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할\n\n\nInternal fragmentation(내부 조각)\n프로그램 크기보다 분할의 크기가 큰 경우\n하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각\n특정 프로그램에 배정되었지만 사용되지 않는 공간\n\n\n\n\nHole\n가용 메모리 공간\n다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음\n프로세스가 도착하면 수용가능한 hole을 할당\n운영체제는 다음의 정보를 유지\n할당 공간\n가용 공간 (hole)\n\n\n\n\n\n\n\n\nDynamic Storage-Allocation Problem\n\n가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제\n\n방식 종류\n\nFirst-fit\nSize가 n 이상인 것 중 최초로 찾아지는 hole에 할당\n\n\nBest-fit\nSize가 n 이상인 가장 작은 hole을 찾아서 할당\nHole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함\n많은 수의 아주 작은 hole들이 생성됨\n\n\nWorst-fit\n가장 큰 hole에 할당\n역시 모든 리스트를 탐색해야 함\n상대적으로 아주 큰 hole들이 생성됨\n\n\n\nFirst-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 효과적인 것으로 알려짐(실험적인 결과) -&gt; Worst-fit은 탐색 + 더 큰 프로그램의 메모리 hole을 차지하기 때문이다\n\n\n\nCompaction\n\nexternal fragmentation 문제를 해결하는 한 가지 방법\n사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것\n매우 비용이 많이 드는 방법임\n최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)\nCompaction은 프로세스의 주소가 실행 시간에 동적을 재배치가 가능한 경우에만 수행될 수 있다\n\n\n\nPaging\nPaging\nProcess의 virtual memory를 동일한 사이즈의 page 단위로 나눔\nVirtual memory의 내용이 page 단위로 noncontiguous하게 저장됨\n일부는 backing storage에, 일부는 physical memory에 저장\n\n\nBasic Method\nphysical memory를 동일한 크기의 frame으로 나눔\nlogical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)\n모든 가용 frame들을 관리\npage table을 사용하여 logical address를 physical address로 변환\nExternal fragmentation 발생 안함\nInternal fragmentation 발생 가능 (마지막으로 나눠진 Page의 크기가 작기 때문)\n\n\n\n\n\nImplemntation Of Page Table\nPage table은 main memory에 상주\nPage-table base register (PTBR)가 page table을 가리킴\nPage-table length register (PTLR)가 테이블 크기를 보관\n모든 메모리 접근 연산에는 2번의 memory access필요\npage table 접근 1번, 실제 data/instruction 접근 1번\n\n\n\n속도 향상을 위해\nassociatve register 혹은 translation look-aside buffer(TLB)라 불리는\n고속의 lookup hardware cache 사용\nTLB\n\n\nAssociative registers (TLB): parallel search가 가능\n\nTLB에는 page table 중 일부만 존재\n\n\nAddress translation\n\npage table 중 일부가 associative register에 보관되어 있음\n만약 해당 page #가 associative register에 있는 경우 곧바로 frame #를 얻음\n그렇지 않은 경우 main memory에 있는 page table로부터 frame #를 얻음\nTLB는 context switch 때 flush (remove old entries)\n\n\nEffective Access Time\n  \n\n\n\nTwo-Level Page Table\n현대의 컴퓨터는 address space가 매우 큰 프로그램 지원\n\n32 bit address 사용시: 2^32(4G)의 주소 공간\n\npage size가 4K시 1M개의 page table entry 필요\n\n각 page entry가 4B시 프로세스 당 4M의 page table 필요\n\n그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 page table 공간이 심하게 낭비됨\n  -&gt; page table 자체를 page로 구성\n  -&gt; 사용하지 않는 주소 공간에 대한 outer page table의 엔트리 값은 NULL (대응하는 inner page table이 없음\n\n\n\n\n\n\n\n\n\nExample\n\nlogical address (on 32-bit machine with 4K page size) 구성\n\n20bit의 page number\n12bit의 page offset\n\n\npage table 자체가 page로 구성되기 때문에 page number는 다음과 같이 나뉜다 (각 page table entry가 4B)\n\n10-bit의 outer page number\n10-bit의 inner page number\n12bit의 page offset\n\n\n따라서, logical address는 다음과 같다\n  \n\nP1은 outer page table의 index이고\n\nP2는 outer page table의 page에서의 변위(displacement)\n\n\n\n2단계 페이징에서 Address-translation scheme\n  \n## Multilevel Paging and Performance\nAddress space가 더 커지면 다단계 페에지 테이블 필요\n\n각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요\n\nTLB를 통해 메모리 접근 시간을 줄일 수 있음\n\n4단계 페이지 테이블 을 사용하는 경우 \n\n메모리 접근 시간이 100ns, TLB 접근 시간이 20ns이고\nTLB hit ratio가 98%인 경우\neffective memory access time = 0.98 * 120 + 0.02 * 520 = 128 nanoseconds\n\n\n결과적으로 주소변환을 위해 28ns만 소요\n\n\n\nMemory Protection\nPage table의 각 entry마다 아래의 bit를 둔다\nProtection bit\npage에 대한 접근 권한 (read/wrtie/read-only)\n\n\nValid-invalid bit\n“valid”는 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함 (접근 허용)\n“invalid”는 해당 주소의 frame에 유효한 내용이 없음을 뜻함 (접근 불허)\n프로세스가 그 주소 부분을 사용하지 않는 경우\n해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우\n\n\n\n\n\n\n\n\n\nInverted Page table\npage table이 매우 큰 이유\n모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry가 존재\n대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재\n\n\nInverted page table\nPage frame 하나당 page table에 하나의 entry를 둔 것 (system-wide)\n각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address)\n모든 프로세스에 대해서 한 개의 페이지 테이블로 관리\n단점\n테이블 전체를 탐색해야한다\n\n\n조치\nassociative register 사용 (expensive)\n\n\n\n\n\n\n\nShared Page\nShared code\nRe-entrant Code (=Pure code)\nread-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (eg. text editors, compilers, window systems)\nShared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함\n\n\nPrivate code and data\n각 프로세스들은 독자적으로 메모리에 올림\nPrivate data는 logical address space의 아무 곳에 와도 무방\n\n\n\n\n\nSegmentation\n프로그램은 의미 단위인 여러 개의 segment로 구성\n작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의\n크게는 프로그램 전체를 하나의 세그먼트로 정의 가능\n일반적으로 code, data, stack 부분이 하나씩의 세그먼트로 정의됨\n\n\nSegment는 다음과 같은 logical unit 들임\nmain()\nfunction\nglobal variables\nstack\nsymbol table, arrays\n\n\n\n\n\nSegmentation Architecture\nLogical address는 다음의 두 가지로 구성\n&lt; segment-number, offset &gt;\n\n\nSegment table\neach table entry has:\nbase : starting physical address of the segment\nlimit : length of the segment\n\n\nPage 보다 테이블 크기가 작아서 메모리 낭비가 적다\n\n\nSegment-table base register (STBR)\n물리적 메모리에서의 segment table의 위치 \n\n\nSegment-table length register (STLR)\n프로그램이 사용하는 segment의 수\nsegment number s is legal if s &lt; STLR\n\n\n\n\n\n\n\n\nProtection\n각 세그먼트 별로 protection bit가 있음\nEach entry:\nValid bit = 0 -&gt; illegal segment\nRead/Write/Execution 권한 bit\n\n\n\n\nSharing\nshared segment\nsame segment number\nsegment는 의미 단위이기 때문에 공유와 보안에 있어서 paging보다 훨씬 효과적이다\n\n\nAllocation\nfirst fit/ best fit\nexternal fragmentation 발생\nsegment의 길이가 동일하지 않으므로 가변분할 방식에서와 동일한 문제점이 발생한다\n\n\n\n\n\nSegmentation with Paging\npure segmentation과의 차이점\nsegment-table entry가 segment의 base address를 가지고 있는 것이 아니라 segment를 구성하는 page table의  base address를 가지고 있음\n\n\n\n\n\n사용 이유는 Segmentation의 의미 단위로 묶였을 때 Protection과 Sharing등의 장점과\nPaging를 통해 외부 단편화를 없애는 장점을 같이 사용하기 위해서 이다\n참고\n반효경 교수님 운영체제 강의\n\n","dateCreated":"2021-07-26T10:36:55+09:00","dateModified":"2021-07-27T15:46:29+09:00","datePublished":"2021-07-26T10:36:55+09:00","description":"","headline":"OS-9 Memoery Management","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"},"publisher":{"@type":"Organization","name":"Yechan Kim","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"url":"https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/","keywords":"OS"}</script>
    <meta name="description" content="Logical vs Physical Address Logical address (&#x3D;virtual address) 프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지부터 시작 CPU가 보는 주소는 logical address다   Physical address 메모리에 실제 올라가는 위치   주소 바인딩: 주소를 결정하는 것 Symbolic Ad">
<meta property="og:type" content="blog">
<meta property="og:title" content="OS-9 Memoery Management">
<meta property="og:url" content="https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/index.html">
<meta property="og:site_name" content="Run PSVM">
<meta property="og:description" content="Logical vs Physical Address Logical address (&#x3D;virtual address) 프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지부터 시작 CPU가 보는 주소는 logical address다   Physical address 메모리에 실제 올라가는 위치   주소 바인딩: 주소를 결정하는 것 Symbolic Ad">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126925182-7bf13f29-2a6d-4fd4-b701-48bef9a46c00.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126925689-aad5db1d-c383-43c3-bfeb-31a0fe849037.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126925967-f9fc2dca-889c-4ff9-99b4-629d54072f8a.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126926799-feec50dc-9193-4683-9f8e-a988dfe47551.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126933294-0249e9a7-54ee-4e15-ad28-2140def869ed.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126933772-7b17e619-24b5-4d17-bd93-98d2802fc486.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126934516-31fd0995-5254-4a43-8f1c-aeeef0a10321.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126943175-4241b29d-f699-4a9a-babf-0959e25854e9.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126944020-fd9f5893-aebd-4e96-a9b1-ad03ad34785f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126944580-9ee3fb4a-71e4-43a1-be86-2cab3ba105c2.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126945583-e8974a5b-20d8-43ad-af1f-8a6bece3d152.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126946223-01c24b2f-f79e-49fe-8650-657438cfc307.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/126946383-c9c3981b-2c2d-4c4b-8ebc-3ce19757ae43.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127098789-bb4445d5-6bcd-417a-a56f-dbe3025bdc5f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127099601-e03ba90c-72d7-4498-ab12-054c19f74989.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127103166-338c3120-08c9-4809-8ba9-5224cbad6334.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127106361-ceb3dd75-6ea7-41bf-8e23-ad546f255cc9.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127105612-38eb8eb8-2e5c-4bc2-ae13-39ddd9f7119b.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127106460-225461cd-41b7-44e4-9944-6d072a26e33d.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/12459864/127107118-1a979fe1-9b7d-4384-aa71-3b1cf7282c05.png">
<meta property="article:published_time" content="2021-07-26T01:36:55.000Z">
<meta property="article:modified_time" content="2021-07-27T06:46:29.510Z">
<meta property="article:author" content="Yechan Kim">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/12459864/126925182-7bf13f29-2a6d-4fd4-b701-48bef9a46c00.png">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Run PSVM
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            OS-9 Memoery Management
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2021-07-26T10:36:55+09:00">
	
		    Jul 26, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Computer-Science/">Computer Science</a>, <a class="category-link" href="/categories/Computer-Science/OS/">OS</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="Logical-vs-Physical-Address"><a href="#Logical-vs-Physical-Address" class="headerlink" title="Logical vs Physical Address"></a>Logical vs Physical Address</h2><ul>
<li>Logical address (=virtual address)<ul>
<li>프로세스마다 독립적으로 가지는 주소 공간</li>
<li>각 프로세스마다 0번지부터 시작</li>
<li>CPU가 보는 주소는 logical address다</li>
</ul>
</li>
<li>Physical address<ul>
<li>메모리에 실제 올라가는 위치</li>
</ul>
</li>
<li>주소 바인딩: 주소를 결정하는 것<ul>
<li>Symbolic Address -&gt; Logical Address -&gt; Physical address</li>
</ul>
</li>
</ul>
<h2 id="주소-바인딩"><a href="#주소-바인딩" class="headerlink" title="주소 바인딩"></a>주소 바인딩</h2><ul>
<li>Compile time binding<ul>
<li>물리적 메모리 주소(physical address)가 컴파일 시 알려짐</li>
<li>시작 위치 변경 시 재컴파일</li>
<li>컴파일러는 절대 코드(absolute code) 생성</li>
</ul>
</li>
<li>Load time binding<ul>
<li>Loader의 책임하에 물리적 메모리 주소 부여</li>
<li>프로그램이 메모리에 올라갈 때 물리적 메모리 주소가 정해짐</li>
<li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능</li>
</ul>
</li>
<li>Execution time binding(= Run time binding)<ul>
<li>수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음</li>
<li>CPU가 주소를 참조할 때마다 binding을 점검 (address mapping table)</li>
<li>실행중에 메모리에 쫓겨나고 다시 메모리에 올라갈 때 (Swapping)</li>
<li>하드웨어 지원이 필요하다 (e.g., base and limit registers, MMU)</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-26 오전 11 31 44" src="https://user-images.githubusercontent.com/12459864/126925182-7bf13f29-2a6d-4fd4-b701-48bef9a46c00.png">

<h2 id="Memory-Management-Unit-MMU"><a href="#Memory-Management-Unit-MMU" class="headerlink" title="Memory-Management Unit (MMU)"></a>Memory-Management Unit (MMU)</h2><ul>
<li>MMU (Memory-Management Unit)<ul>
<li>logical address를 physical address로 매핑해 주는 Hardware device</li>
</ul>
</li>
<li>MMU scheme<ul>
<li>사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (= relocation register)의 값을 더한다</li>
</ul>
</li>
<li>user program<ul>
<li>logical address만을 다룬다 </li>
<li>실제 physical address를 볼 수 없으며 알 필요가 없다</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-26 오전 11 39 27" src="https://user-images.githubusercontent.com/12459864/126925689-aad5db1d-c383-43c3-bfeb-31a0fe849037.png">

<h2 id="Hardware-Support-For-Address-Translation"><a href="#Hardware-Support-For-Address-Translation" class="headerlink" title="Hardware Support For Address Translation"></a>Hardware Support For Address Translation</h2><ul>
<li>운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용하는 레지스터</li>
<li>Relocation register(= base register) : 접근할 수 있는 물리적 메모리 주소의 최소값</li>
<li>Limit register: 논리적 주소의 범위</li>
</ul>
<img width="600" alt="스크린샷 2021-07-26 오전 11 43 43" src="https://user-images.githubusercontent.com/12459864/126925967-f9fc2dca-889c-4ff9-99b4-629d54072f8a.png">

<h2 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h2><h3 id="Dynamic-Loading"><a href="#Dynamic-Loading" class="headerlink" title="Dynamic Loading"></a>Dynamic Loading</h3><ul>
<li>프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것</li>
<li>memory utilization의 향상</li>
<li>가끔식 사용되는 많은 양의 코드의 경우 유용 (ex. 오류 처리 루틴)</li>
<li>운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)</li>
<li>Loading: 메모리로 올리는 것</li>
</ul>
<h3 id="Overlays"><a href="#Overlays" class="headerlink" title="Overlays"></a>Overlays</h3><ul>
<li>메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림</li>
<li>프로세스의 크기가 메모리보다 클 때 유용</li>
<li>운영체제의 지원없이 사용자에 의해 구현</li>
<li>작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현<ul>
<li>Manual Overlay</li>
<li>프로그래밍이 매우 복잡</li>
</ul>
</li>
</ul>
<h3 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h3><ul>
<li>Swapping : 프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것</li>
<li>Backing store(=swap area)<ul>
<li>디스크<ul>
<li>많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간</li>
</ul>
</li>
</ul>
</li>
<li>Swap in/ Swap out<ul>
<li>일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정</li>
<li>priority-based CPU scheduling algorithm<ul>
<li>priority가 낮은 프로세스를 swapped out 시킴</li>
<li>priority가 높은 프로세스를 메모리에 올려 놓음</li>
</ul>
</li>
<li>Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야 함</li>
<li>Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음</li>
<li>swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-26 오전 11 54 35" src="https://user-images.githubusercontent.com/12459864/126926799-feec50dc-9193-4683-9f8e-a988dfe47551.png">

<h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><ul>
<li>Linking을 실행 시간(execution time)까지 미루는 기법</li>
<li>Static linking<ul>
<li>라이브러리가 프로그램의 실행 파일 코드에 포함됨</li>
<li>실행 파일의 크기가 커짐</li>
<li>동일한 라이브러리를 각각의 프로스가 메모리에 올리므로 메모리 낭비 (ex. printf 함수의 라이브러리 코드)</li>
</ul>
</li>
<li>Dynamic linking<ul>
<li>라이브러리가 실행 시 연결(link)됨</li>
<li>라이브러리 호출부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠</li>
<li>라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴</li>
<li>운영체제의 도움이 필요</li>
</ul>
</li>
</ul>
<h2 id="Allocation-Of-Physical-Memory"><a href="#Allocation-Of-Physical-Memory" class="headerlink" title="Allocation Of Physical Memory"></a>Allocation Of Physical Memory</h2><ul>
<li>메모리는 일반적으로 두 영역으로 나뉘어 사용<ul>
<li>OS 상주 영역<ul>
<li>interrupt vector와 함께 낮은 주소 영역 사용</li>
</ul>
</li>
<li>사용자 프로세스 영역<ul>
<li>높은 주소 영역 사용   <img width="146" alt="스크린샷 2021-07-26 오후 1 31 47" src="https://user-images.githubusercontent.com/12459864/126933294-0249e9a7-54ee-4e15-ad28-2140def869ed.png"></li>
</ul>
</li>
</ul>
</li>
<li>사용자 프로세스 영역의 할당 방법<ul>
<li>Contiguous allocation : 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것<ul>
<li>Fixed partiion allocation</li>
<li>Variable partition allocation</li>
</ul>
</li>
<li>Noncontigous allocation : 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음<ul>
<li>Paging : 논리 메모리를 같은 크기로 자른다</li>
<li>Segment : 논리 메모리를 의미있는 단위로 자른다 (code, data, stack)</li>
<li>Paged Segmentation</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h3><ul>
<li>고정 분할(Fixed partition) 방식<ul>
<li>물리적 메모리를 몇 개의 영구적 분할(partition)로 나눔</li>
<li>분할의 크기가 모두 동일한 방식과 서로 다른 방식이 존재</li>
<li>분할당 하나의 프로그램 적재</li>
<li>융통성이 없음<ul>
<li>동시에 메모리에 load되는 프로그램의 수가 고정됨</li>
<li>최대 수행 가능 프로그램 크기 제한</li>
</ul>
</li>
<li>가변 분할(Variable partition) 방식<ul>
<li>프로그램의 크기를 고려해서 할당</li>
<li>분할의 크기, 개수가 동적으로 변함</li>
<li>기술적 관리 기법 필요</li>
<li>External fragmentation 발생</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-26 오전 11 05 55" src="https://user-images.githubusercontent.com/12459864/126933772-7b17e619-24b5-4d17-bd93-98d2802fc486.png">

<ul>
<li>Fragmentation<ul>
<li>External fragmentation(외부 조각)<ul>
<li>프로그램 크기보다 분할의 크기가 작은 경우</li>
<li>아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할</li>
</ul>
</li>
<li>Internal fragmentation(내부 조각)<ul>
<li>프로그램 크기보다 분할의 크기가 큰 경우</li>
<li>하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각</li>
<li>특정 프로그램에 배정되었지만 사용되지 않는 공간</li>
</ul>
</li>
</ul>
</li>
<li>Hole<ul>
<li>가용 메모리 공간</li>
<li>다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음</li>
<li>프로세스가 도착하면 수용가능한 hole을 할당</li>
<li>운영체제는 다음의 정보를 유지<ul>
<li>할당 공간</li>
<li>가용 공간 (hole)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="500" alt="스크린샷 2021-07-26 오후 1 48 24" src="https://user-images.githubusercontent.com/12459864/126934516-31fd0995-5254-4a43-8f1c-aeeef0a10321.png">

<ul>
<li><p>Dynamic Storage-Allocation Problem</p>
<ul>
<li><p>가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제</p>
</li>
<li><p>방식 종류</p>
<ol>
<li>First-fit<ul>
<li>Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당</li>
</ul>
</li>
<li>Best-fit<ul>
<li>Size가 n 이상인 가장 작은 hole을 찾아서 할당</li>
<li>Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함</li>
<li>많은 수의 아주 작은 hole들이 생성됨</li>
</ul>
</li>
<li>Worst-fit<ul>
<li>가장 큰 hole에 할당</li>
<li>역시 모든 리스트를 탐색해야 함</li>
<li>상대적으로 아주 큰 hole들이 생성됨</li>
</ul>
</li>
</ol>
<p><code>First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 효과적인 것으로 알려짐(실험적인 결과) -&gt; Worst-fit은 탐색 + 더 큰 프로그램의 메모리 hole을 차지하기 때문이다</code></p>
</li>
</ul>
</li>
<li><p>Compaction</p>
<ul>
<li>external fragmentation 문제를 해결하는 한 가지 방법</li>
<li>사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것</li>
<li>매우 비용이 많이 드는 방법임</li>
<li>최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)</li>
<li>Compaction은 프로세스의 주소가 실행 시간에 동적을 재배치가 가능한 경우에만 수행될 수 있다</li>
</ul>
</li>
</ul>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><ul>
<li>Paging<ul>
<li>Process의 virtual memory를 동일한 사이즈의 page 단위로 나눔</li>
<li>Virtual memory의 내용이 page 단위로 noncontiguous하게 저장됨</li>
<li>일부는 backing storage에, 일부는 physical memory에 저장</li>
</ul>
</li>
<li>Basic Method<ul>
<li>physical memory를 동일한 크기의 frame으로 나눔</li>
<li>logical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)</li>
<li>모든 가용 frame들을 관리</li>
<li>page table을 사용하여 logical address를 physical address로 변환</li>
<li>External fragmentation 발생 안함</li>
<li>Internal fragmentation 발생 가능 (마지막으로 나눠진 Page의 크기가 작기 때문)</li>
</ul>
</li>
</ul>
<img width="500" alt="스크린샷 2021-07-26 오후 3 30 43" src="https://user-images.githubusercontent.com/12459864/126943175-4241b29d-f699-4a9a-babf-0959e25854e9.png">

<h3 id="Implemntation-Of-Page-Table"><a href="#Implemntation-Of-Page-Table" class="headerlink" title="Implemntation Of Page Table"></a>Implemntation Of Page Table</h3><ul>
<li>Page table은 main memory에 상주</li>
<li>Page-table base register (PTBR)가 page table을 가리킴</li>
<li>Page-table length register (PTLR)가 테이블 크기를 보관</li>
<li>모든 메모리 접근 연산에는 2번의 memory access필요<ul>
<li>page table 접근 1번, 실제 data/instruction 접근 1번</li>
</ul>
</li>
</ul>
<p><code>속도 향상을 위해</code></p>
<p><code>associatve register 혹은 translation look-aside buffer(TLB)라 불리는</code></p>
<p><code>고속의 lookup hardware cache 사용</code></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><img width="600" alt="스크린샷 2021-07-26 오후 3 38 24" src="https://user-images.githubusercontent.com/12459864/126944020-fd9f5893-aebd-4e96-a9b1-ad03ad34785f.png">

<ul>
<li><p>Associative registers (TLB): parallel search가 가능</p>
<ul>
<li>TLB에는 page table 중 일부만 존재</li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>page table 중 일부가 associative register에 보관되어 있음</li>
<li>만약 해당 page #가 associative register에 있는 경우 곧바로 frame #를 얻음</li>
<li>그렇지 않은 경우 main memory에 있는 page table로부터 frame #를 얻음</li>
<li>TLB는 context switch 때 flush (remove old entries)</li>
</ul>
</li>
<li><p>Effective Access Time</p>
  <img width="400" alt="스크린샷 2021-07-26 오후 3 43 22" src="https://user-images.githubusercontent.com/12459864/126944580-9ee3fb4a-71e4-43a1-be86-2cab3ba105c2.png">

</li>
</ul>
<h2 id="Two-Level-Page-Table"><a href="#Two-Level-Page-Table" class="headerlink" title="Two-Level Page Table"></a>Two-Level Page Table</h2><ul>
<li><p>현대의 컴퓨터는 address space가 매우 큰 프로그램 지원</p>
<ul>
<li><p>32 bit address 사용시: 2^32(4G)의 주소 공간</p>
<ul>
<li><p>page size가 4K시 1M개의 page table entry 필요</p>
</li>
<li><p>각 page entry가 4B시 프로세스 당 4M의 page table 필요</p>
</li>
<li><p><code>그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 page table 공간이 심하게 낭비됨</code></p>
<p>  <code>-&gt; page table 자체를 page로 구성</code></p>
<p>  <code>-&gt; 사용하지 않는 주소 공간에 대한 outer page table의 엔트리 값은 NULL (대응하는 inner page table이 없음</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="500" alt="스크린샷 2021-07-26 오후 3 53 42" src="https://user-images.githubusercontent.com/12459864/126945583-e8974a5b-20d8-43ad-af1f-8a6bece3d152.png">

<ul>
<li><p>Example</p>
<ul>
<li><p>logical address (on 32-bit machine with 4K page size) 구성</p>
<ul>
<li>20bit의 page number</li>
<li>12bit의 page offset</li>
</ul>
</li>
<li><p>page table 자체가 page로 구성되기 때문에 page number는 다음과 같이 나뉜다 (각 page table entry가 4B)</p>
<ul>
<li>10-bit의 outer page number</li>
<li>10-bit의 inner page number</li>
<li>12bit의 page offset</li>
</ul>
</li>
<li><p>따라서, logical address는 다음과 같다</p>
  <img width="369" alt="스크린샷 2021-07-26 오후 3 58 15" src="https://user-images.githubusercontent.com/12459864/126946223-01c24b2f-f79e-49fe-8650-657438cfc307.png">
</li>
<li><p>P1은 outer page table의 index이고</p>
</li>
<li><p>P2는 outer page table의 page에서의 변위(displacement)</p>
</li>
</ul>
</li>
<li><p>2단계 페이징에서 Address-translation scheme</p>
  <img width="500" alt="스크린샷 2021-07-26 오후 4 00 12" src="https://user-images.githubusercontent.com/12459864/126946383-c9c3981b-2c2d-4c4b-8ebc-3ce19757ae43.png">
## Multilevel Paging and Performance</li>
<li><p>Address space가 더 커지면 다단계 페에지 테이블 필요</p>
</li>
<li><p>각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요</p>
</li>
<li><p>TLB를 통해 메모리 접근 시간을 줄일 수 있음</p>
</li>
<li><p>4단계 페이지 테이블 을 사용하는 경우 </p>
<ul>
<li>메모리 접근 시간이 100ns, TLB 접근 시간이 20ns이고</li>
<li>TLB hit ratio가 98%인 경우<ul>
<li>effective memory access time = 0.98 * 120 + 0.02 * 520 = 128 nanoseconds</li>
</ul>
</li>
<li>결과적으로 주소변환을 위해 28ns만 소요</li>
</ul>
</li>
</ul>
<h2 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h2><ul>
<li>Page table의 각 entry마다 아래의 bit를 둔다<ul>
<li>Protection bit<ul>
<li>page에 대한 접근 권한 (read/wrtie/read-only)</li>
</ul>
</li>
<li>Valid-invalid bit<ul>
<li>“valid”는 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함 (접근 허용)</li>
<li>“invalid”는 해당 주소의 frame에 유효한 내용이 없음을 뜻함 (접근 불허)<ul>
<li>프로세스가 그 주소 부분을 사용하지 않는 경우</li>
<li>해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="500" alt="스크린샷 2021-07-27 오후 2 06 58" src="https://user-images.githubusercontent.com/12459864/127098789-bb4445d5-6bcd-417a-a56f-dbe3025bdc5f.png">

<h2 id="Inverted-Page-table"><a href="#Inverted-Page-table" class="headerlink" title="Inverted Page table"></a>Inverted Page table</h2><ul>
<li>page table이 매우 큰 이유<ul>
<li>모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry가 존재</li>
<li>대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재</li>
</ul>
</li>
<li>Inverted page table<ul>
<li>Page frame 하나당 page table에 하나의 entry를 둔 것 (system-wide)</li>
<li>각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address)</li>
<li>모든 프로세스에 대해서 한 개의 페이지 테이블로 관리</li>
<li>단점<ul>
<li>테이블 전체를 탐색해야한다</li>
</ul>
</li>
<li>조치<ul>
<li>associative register 사용 (expensive)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-27 오후 2 17 32" src="https://user-images.githubusercontent.com/12459864/127099601-e03ba90c-72d7-4498-ab12-054c19f74989.png">

<h2 id="Shared-Page"><a href="#Shared-Page" class="headerlink" title="Shared Page"></a>Shared Page</h2><ul>
<li>Shared code<ul>
<li>Re-entrant Code (=Pure code)</li>
<li>read-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (eg. text editors, compilers, window systems)</li>
<li>Shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함</li>
</ul>
</li>
<li>Private code and data<ul>
<li>각 프로세스들은 독자적으로 메모리에 올림</li>
<li>Private data는 logical address space의 아무 곳에 와도 무방</li>
</ul>
</li>
</ul>
<img width="500" alt="스크린샷 2021-07-27 오후 2 57 02" src="https://user-images.githubusercontent.com/12459864/127103166-338c3120-08c9-4809-8ba9-5224cbad6334.png">

<h2 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h2><ul>
<li>프로그램은 의미 단위인 여러 개의 segment로 구성<ul>
<li>작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의</li>
<li>크게는 프로그램 전체를 하나의 세그먼트로 정의 가능</li>
<li>일반적으로 code, data, stack 부분이 하나씩의 세그먼트로 정의됨</li>
</ul>
</li>
<li>Segment는 다음과 같은 logical unit 들임<ul>
<li>main()</li>
<li>function</li>
<li>global variables</li>
<li>stack</li>
<li>symbol table, arrays</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-27 오후 3 28 07" src="https://user-images.githubusercontent.com/12459864/127106361-ceb3dd75-6ea7-41bf-8e23-ad546f255cc9.png">

<h3 id="Segmentation-Architecture"><a href="#Segmentation-Architecture" class="headerlink" title="Segmentation Architecture"></a>Segmentation Architecture</h3><ul>
<li>Logical address는 다음의 두 가지로 구성<ul>
<li>&lt; segment-number, offset &gt;</li>
</ul>
</li>
<li>Segment table<ul>
<li>each table entry has:<ul>
<li>base : starting physical address of the segment</li>
<li>limit : length of the segment</li>
</ul>
</li>
<li>Page 보다 테이블 크기가 작아서 메모리 낭비가 적다</li>
</ul>
</li>
<li>Segment-table base register (STBR)<ul>
<li>물리적 메모리에서의 segment table의 위치 </li>
</ul>
</li>
<li>Segment-table length register (STLR)<ul>
<li>프로그램이 사용하는 segment의 수<ul>
<li>segment number s is legal if s &lt; STLR</li>
</ul>
</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-27 오후 3 20 54" src="https://user-images.githubusercontent.com/12459864/127105612-38eb8eb8-2e5c-4bc2-ae13-39ddd9f7119b.png">

<ul>
<li>Protection<ul>
<li>각 세그먼트 별로 protection bit가 있음</li>
<li>Each entry:<ul>
<li>Valid bit = 0 -&gt; illegal segment</li>
<li>Read/Write/Execution 권한 bit</li>
</ul>
</li>
</ul>
</li>
<li>Sharing<ul>
<li>shared segment</li>
<li>same segment number</li>
<li>segment는 의미 단위이기 때문에 공유와 보안에 있어서 paging보다 훨씬 효과적이다</li>
</ul>
</li>
<li>Allocation<ul>
<li>first fit/ best fit</li>
<li>external fragmentation 발생</li>
<li>segment의 길이가 동일하지 않으므로 가변분할 방식에서와 동일한 문제점이 발생한다</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-27 오후 3 29 13" src="https://user-images.githubusercontent.com/12459864/127106460-225461cd-41b7-44e4-9944-6d072a26e33d.png">

<h2 id="Segmentation-with-Paging"><a href="#Segmentation-with-Paging" class="headerlink" title="Segmentation with Paging"></a>Segmentation with Paging</h2><ul>
<li>pure segmentation과의 차이점<ul>
<li>segment-table entry가 segment의 base address를 가지고 있는 것이 아니라 segment를 구성하는 page table의  base address를 가지고 있음</li>
</ul>
</li>
</ul>
<img width="600" alt="스크린샷 2021-07-27 오후 3 34 24" src="https://user-images.githubusercontent.com/12459864/127107118-1a979fe1-9b7d-4384-aa71-3b1cf7282c05.png">

<p><code>사용 이유는 Segmentation의 의미 단위로 묶였을 때 Protection과 Sharing등의 장점과</code></p>
<p><code>Paging를 통해 외부 단편화를 없애는 장점을 같이 사용하기 위해서 이다</code></p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li>반효경 교수님 운영체제 강의</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/OS/" rel="tag">OS</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/07/24/OS-8-Dead-Lock/"
                    data-tooltip="OS-8-Dead Lock"
                    aria-label="NEXT: OS-8-Dead Lock"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 Yechan Kim. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/07/24/OS-8-Dead-Lock/"
                    data-tooltip="OS-8-Dead Lock"
                    aria-label="NEXT: OS-8-Dead Lock"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Yechan Kim</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    
        <script>
          var disqus_config = function() {
            this.page.url = 'https://kimyechan.github.io/2021/07/26/OS-9-Memoery-Management/';
              
            this.page.identifier = '2021/07/26/OS-9-Memoery-Management/';
              
          };
          (function() {
            var d = document, s = d.createElement('script');
            var disqus_shortname = 'xhandev';
            s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
    




    </body>
</html>
